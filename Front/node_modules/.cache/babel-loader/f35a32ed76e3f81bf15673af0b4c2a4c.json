{"ast":null,"code":"/*\n * pkginfo.js: Top-level include for the pkginfo module\n *\n * (C) 2011, Charlie Robbins\n *\n */\nvar fs = require('fs'),\n    path = require('path'); //\n// ### function pkginfo ([options, 'property', 'property' ..])\n// #### @pmodule {Module} Parent module to read from.\n// #### @options {Object|Array|string} **Optional** Options used when exposing properties.\n// #### @arguments {string...} **Optional** Specified properties to expose.\n// Exposes properties from the package.json file for the parent module on \n// it's exports. Valid usage:\n//\n// `require('pkginfo')()`\n//\n// `require('pkginfo')('version', 'author');`\n//\n// `require('pkginfo')(['version', 'author']);`\n//\n// `require('pkginfo')({ include: ['version', 'author'] });`\n//\n\n\nvar pkginfo = module.exports = function (pmodule, options) {\n  var args = [].slice.call(arguments, 2).filter(function (arg) {\n    return typeof arg === 'string';\n  }); //\n  // **Parse variable arguments**\n  //\n\n  if (Array.isArray(options)) {\n    //\n    // If the options passed in is an Array assume that\n    // it is the Array of properties to expose from the\n    // on the package.json file on the parent module.\n    //\n    options = {\n      include: options\n    };\n  } else if (typeof options === 'string') {\n    //\n    // Otherwise if the first argument is a string, then\n    // assume that it is the first property to expose from\n    // the package.json file on the parent module.\n    //\n    options = {\n      include: [options]\n    };\n  } //\n  // **Setup default options**\n  //\n\n\n  options = options || {\n    include: []\n  };\n\n  if (args.length > 0) {\n    //\n    // If additional string arguments have been passed in\n    // then add them to the properties to expose on the \n    // parent module. \n    //\n    options.include = options.include.concat(args);\n  }\n\n  var pkg = pkginfo.read(pmodule, options.dir).package;\n  Object.keys(pkg).forEach(function (key) {\n    if (options.include.length > 0 && !~options.include.indexOf(key)) {\n      return;\n    }\n\n    if (!pmodule.exports[key]) {\n      pmodule.exports[key] = pkg[key];\n    }\n  });\n  return pkginfo;\n}; //\n// ### function find (dir)\n// #### @pmodule {Module} Parent module to read from.\n// #### @dir {string} **Optional** Directory to start search from.\n// Searches up the directory tree from `dir` until it finds a directory\n// which contains a `package.json` file. \n//\n\n\npkginfo.find = function (pmodule, dir) {\n  dir = dir || pmodule.filename;\n  dir = path.dirname(dir);\n  var files = fs.readdirSync(dir);\n\n  if (~files.indexOf('package.json')) {\n    return path.join(dir, 'package.json');\n  }\n\n  if (dir === '/') {\n    throw new Error('Could not find package.json up from: ' + dir);\n  } else if (!dir || dir === '.') {\n    throw new Error('Cannot find package.json from unspecified directory');\n  }\n\n  return pkginfo.find(pmodule, dir);\n}; //\n// ### function read (pmodule, dir)\n// #### @pmodule {Module} Parent module to read from.\n// #### @dir {string} **Optional** Directory to start search from.\n// Searches up the directory tree from `dir` until it finds a directory\n// which contains a `package.json` file and returns the package information.\n//\n\n\npkginfo.read = function (pmodule, dir) {\n  dir = pkginfo.find(pmodule, dir);\n  var data = fs.readFileSync(dir).toString();\n  return {\n    dir: dir,\n    package: JSON.parse(data)\n  };\n}; //\n// Call `pkginfo` on this module and expose version.\n//\n\n\npkginfo(module, {\n  dir: __dirname,\n  include: ['version'],\n  target: pkginfo\n});","map":null,"metadata":{},"sourceType":"script"}