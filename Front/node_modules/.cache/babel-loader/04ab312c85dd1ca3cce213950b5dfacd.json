{"ast":null,"code":"// Load modules.\nvar passport = require('passport-strategy'),\n    url = require('url'),\n    util = require('util'),\n    utils = require('./utils'),\n    OAuth2 = require('oauth').OAuth2,\n    NullStateStore = require('./state/null'),\n    SessionStateStore = require('./state/session'),\n    AuthorizationError = require('./errors/authorizationerror'),\n    TokenError = require('./errors/tokenerror'),\n    InternalOAuthError = require('./errors/internaloautherror');\n/**\n * Creates an instance of `OAuth2Strategy`.\n *\n * The OAuth 2.0 authentication strategy authenticates requests using the OAuth\n * 2.0 framework.\n *\n * OAuth 2.0 provides a facility for delegated authentication, whereby users can\n * authenticate using a third-party service such as Facebook.  Delegating in\n * this manner involves a sequence of events, including redirecting the user to\n * the third-party service for authorization.  Once authorization has been\n * granted, the user is redirected back to the application and an authorization\n * code can be used to obtain credentials.\n *\n * Applications must supply a `verify` callback, for which the function\n * signature is:\n *\n *     function(accessToken, refreshToken, profile, done) { ... }\n *\n * The verify callback is responsible for finding or creating the user, and\n * invoking `done` with the following arguments:\n *\n *     done(err, user, info);\n *\n * `user` should be set to `false` to indicate an authentication failure.\n * Additional `info` can optionally be passed as a third argument, typically\n * used to display informational messages.  If an exception occured, `err`\n * should be set.\n *\n * Options:\n *\n *   - `authorizationURL`  URL used to obtain an authorization grant\n *   - `tokenURL`          URL used to obtain an access token\n *   - `clientID`          identifies client to service provider\n *   - `clientSecret`      secret used to establish ownership of the client identifer\n *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization\n *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)\n *\n * Examples:\n *\n *     passport.use(new OAuth2Strategy({\n *         authorizationURL: 'https://www.example.com/oauth2/authorize',\n *         tokenURL: 'https://www.example.com/oauth2/token',\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret'\n *         callbackURL: 'https://www.example.net/auth/example/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @constructor\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\n\n\nfunction OAuth2Strategy(options, verify) {\n  if (typeof options == 'function') {\n    verify = options;\n    options = undefined;\n  }\n\n  options = options || {};\n\n  if (!verify) {\n    throw new TypeError('OAuth2Strategy requires a verify callback');\n  }\n\n  if (!options.authorizationURL) {\n    throw new TypeError('OAuth2Strategy requires a authorizationURL option');\n  }\n\n  if (!options.tokenURL) {\n    throw new TypeError('OAuth2Strategy requires a tokenURL option');\n  }\n\n  if (!options.clientID) {\n    throw new TypeError('OAuth2Strategy requires a clientID option');\n  }\n\n  passport.Strategy.call(this);\n  this.name = 'oauth2';\n  this._verify = verify; // NOTE: The _oauth2 property is considered \"protected\".  Subclasses are\n  //       allowed to use it when making protected resource requests to retrieve\n  //       the user profile.\n\n  this._oauth2 = new OAuth2(options.clientID, options.clientSecret, '', options.authorizationURL, options.tokenURL, options.customHeaders);\n  this._callbackURL = options.callbackURL;\n  this._scope = options.scope;\n  this._scopeSeparator = options.scopeSeparator || ' ';\n  this._key = options.sessionKey || 'oauth2:' + url.parse(options.authorizationURL).hostname;\n\n  if (options.store) {\n    this._stateStore = options.store;\n  } else {\n    if (options.state) {\n      this._stateStore = new SessionStateStore({\n        key: this._key\n      });\n    } else {\n      this._stateStore = new NullStateStore();\n    }\n  }\n\n  this._trustProxy = options.proxy;\n  this._passReqToCallback = options.passReqToCallback;\n  this._skipUserProfile = options.skipUserProfile === undefined ? false : options.skipUserProfile;\n} // Inherit from `passport.Strategy`.\n\n\nutil.inherits(OAuth2Strategy, passport.Strategy);\n/**\n * Authenticate request by delegating to a service provider using OAuth 2.0.\n *\n * @param {Object} req\n * @api protected\n */\n\nOAuth2Strategy.prototype.authenticate = function (req, options) {\n  options = options || {};\n  var self = this;\n\n  if (req.query && req.query.error) {\n    if (req.query.error == 'access_denied') {\n      return this.fail({\n        message: req.query.error_description\n      });\n    } else {\n      return this.error(new AuthorizationError(req.query.error_description, req.query.error, req.query.error_uri));\n    }\n  }\n\n  var callbackURL = options.callbackURL || this._callbackURL;\n\n  if (callbackURL) {\n    var parsed = url.parse(callbackURL);\n\n    if (!parsed.protocol) {\n      // The callback URL is relative, resolve a fully qualified URL from the\n      // URL of the originating request.\n      callbackURL = url.resolve(utils.originalURL(req, {\n        proxy: this._trustProxy\n      }), callbackURL);\n    }\n  }\n\n  var meta = {\n    authorizationURL: this._oauth2._authorizeUrl,\n    tokenURL: this._oauth2._accessTokenUrl,\n    clientID: this._oauth2._clientId\n  };\n\n  if (req.query && req.query.code) {\n    function loaded(err, ok, state) {\n      if (err) {\n        return self.error(err);\n      }\n\n      if (!ok) {\n        return self.fail(state, 403);\n      }\n\n      var code = req.query.code;\n      var params = self.tokenParams(options);\n      params.grant_type = 'authorization_code';\n\n      if (callbackURL) {\n        params.redirect_uri = callbackURL;\n      }\n\n      self._oauth2.getOAuthAccessToken(code, params, function (err, accessToken, refreshToken, params) {\n        if (err) {\n          return self.error(self._createOAuthError('Failed to obtain access token', err));\n        }\n\n        self._loadUserProfile(accessToken, function (err, profile) {\n          if (err) {\n            return self.error(err);\n          }\n\n          function verified(err, user, info) {\n            if (err) {\n              return self.error(err);\n            }\n\n            if (!user) {\n              return self.fail(info);\n            }\n\n            info = info || {};\n\n            if (state) {\n              info.state = state;\n            }\n\n            self.success(user, info);\n          }\n\n          try {\n            if (self._passReqToCallback) {\n              var arity = self._verify.length;\n\n              if (arity == 6) {\n                self._verify(req, accessToken, refreshToken, params, profile, verified);\n              } else {\n                // arity == 5\n                self._verify(req, accessToken, refreshToken, profile, verified);\n              }\n            } else {\n              var arity = self._verify.length;\n\n              if (arity == 5) {\n                self._verify(accessToken, refreshToken, params, profile, verified);\n              } else {\n                // arity == 4\n                self._verify(accessToken, refreshToken, profile, verified);\n              }\n            }\n          } catch (ex) {\n            return self.error(ex);\n          }\n        });\n      });\n    }\n\n    var state = req.query.state;\n\n    try {\n      var arity = this._stateStore.verify.length;\n\n      if (arity == 4) {\n        this._stateStore.verify(req, state, meta, loaded);\n      } else {\n        // arity == 3\n        this._stateStore.verify(req, state, loaded);\n      }\n    } catch (ex) {\n      return this.error(ex);\n    }\n  } else {\n    var params = this.authorizationParams(options);\n    params.response_type = 'code';\n\n    if (callbackURL) {\n      params.redirect_uri = callbackURL;\n    }\n\n    var scope = options.scope || this._scope;\n\n    if (scope) {\n      if (Array.isArray(scope)) {\n        scope = scope.join(this._scopeSeparator);\n      }\n\n      params.scope = scope;\n    }\n\n    var state = options.state;\n\n    if (state) {\n      params.state = state;\n\n      var location = this._oauth2.getAuthorizeUrl(params);\n\n      this.redirect(location);\n    } else {\n      function stored(err, state) {\n        if (err) {\n          return self.error(err);\n        }\n\n        if (state) {\n          params.state = state;\n        }\n\n        var location = self._oauth2.getAuthorizeUrl(params);\n\n        self.redirect(location);\n      }\n\n      try {\n        var arity = this._stateStore.store.length;\n\n        if (arity == 3) {\n          this._stateStore.store(req, meta, stored);\n        } else {\n          // arity == 2\n          this._stateStore.store(req, stored);\n        }\n      } catch (ex) {\n        return this.error(ex);\n      }\n    }\n  }\n};\n/**\n * Retrieve user profile from service provider.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to load the user's profile from the service provider.  This assists\n * applications (and users of those applications) in the initial registration\n * process by automatically submitting required information.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.userProfile = function (accessToken, done) {\n  return done(null, {});\n};\n/**\n * Return extra parameters to be included in the authorization request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting authorization.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @param {Object} options\n * @return {Object}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.authorizationParams = function (options) {\n  return {};\n};\n/**\n * Return extra parameters to be included in the token request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting an access token.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @return {Object}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.tokenParams = function (options) {\n  return {};\n};\n/**\n * Parse error response from OAuth 2.0 endpoint.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to parse error responses received from the token endpoint, allowing the\n * most informative message to be displayed.\n *\n * If this function is not overridden, the body will be parsed in accordance\n * with RFC 6749, section 5.2.\n *\n * @param {String} body\n * @param {Number} status\n * @return {Error}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.parseErrorResponse = function (body, status) {\n  var json = JSON.parse(body);\n\n  if (json.error) {\n    return new TokenError(json.error_description, json.error, json.error_uri);\n  }\n\n  return null;\n};\n/**\n * Load user profile, contingent upon options.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api private\n */\n\n\nOAuth2Strategy.prototype._loadUserProfile = function (accessToken, done) {\n  var self = this;\n\n  function loadIt() {\n    return self.userProfile(accessToken, done);\n  }\n\n  function skipIt() {\n    return done(null);\n  }\n\n  if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {\n    // async\n    this._skipUserProfile(accessToken, function (err, skip) {\n      if (err) {\n        return done(err);\n      }\n\n      if (!skip) {\n        return loadIt();\n      }\n\n      return skipIt();\n    });\n  } else {\n    var skip = typeof this._skipUserProfile == 'function' ? this._skipUserProfile() : this._skipUserProfile;\n\n    if (!skip) {\n      return loadIt();\n    }\n\n    return skipIt();\n  }\n};\n/**\n * Create an OAuth error.\n *\n * @param {String} message\n * @param {Object|Error} err\n * @api private\n */\n\n\nOAuth2Strategy.prototype._createOAuthError = function (message, err) {\n  var e;\n\n  if (err.statusCode && err.data) {\n    try {\n      e = this.parseErrorResponse(err.data, err.statusCode);\n    } catch (_) {}\n  }\n\n  if (!e) {\n    e = new InternalOAuthError(message, err);\n  }\n\n  return e;\n}; // Expose constructor.\n\n\nmodule.exports = OAuth2Strategy;","map":null,"metadata":{},"sourceType":"script"}